<!-- THIS DOCUMENT WAS AUTO GENERATED BY TYPESHARP (modified) -->
## Strict types
This is **not** typescript! Something that works in typescript may not work in TypeSharp!
Consider this example:
```ts
const myLovelyVariable = '';

function myCall(param: any): string {
     return param + myLovelyVariable;
}
```
You will get:
```xl
[Type error]
|
(file.tsc):1 --> const myLovelyVariable = '';
|                    ~~~~~~~~~~~~~~~~
\___________________ ^^^
|  ---> Constant expression "myLovelyVariable" must include type.
SP> const myLovelVariable: string = '';

[Unknown Type error]
|
(file.tsc):4 -->     return param + myLovelyVariable;
|                           ~~~~~
\___________________________^^^
|  ---> Paramater is treated as "any" but conecated with string.
SP> return (string) param + myLovelyVariable
```
This is because TypeSharp is **type safe** and expects typings. So our finished code from above would look like this in typesharp:
```ts
const myLovelyVariable: string = '';

function myCall(param: any): string {
     return (string)param + myLovelyVariable;
}
```
##  Prototypes do not work
Support for prototypes may come in the future, but for now, the will not work. Consider the following example from typescript that adds a function to an object:
```ts
const obj: any = {};

obj.prototype.doThis = () => {
     console.log('Niceee');
}

obj.doThis();
// Logs "Niceee"
```
Running this in typesharp will produce the following errors:
```xl
[Delceration error]
|
(file.tsc):1 --> obj.prototype.doThis = () => {
|                    ~~~~~~~~~~~~~~~~~~
\____________________^^^
|  --->  Can can not define "doThis" on undefined.
SP> obj.doThis = () => {
```
